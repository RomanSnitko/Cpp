# LRU Cache на Boost.Intrusive

## Что такое интрузивные структуры данных

Интрузивная структура данных — это контейнер, в котором служебные поля
(например `prev/next` для списка или указатели для хэш-таблицы)
хранятся **внутри самого объекта**, а не в отдельном узле, создаваемом контейнером.

Контейнер:
- не выделяет память под элементы
- не владеет объектами
- не управляет их временем жизни
- лишь связывает уже существующие объекты

Это низкоуровневый подход, применяемый в системном и высокопроизводительном коде
(Linux kernel, game engines, low-latency системы).

---

## Отличие от std-контейнеров

### std::list / std::unordered_map

Стандартные контейнеры являются *node-based*:
```
Node {
T value;
Node* prev;
Node* next;
}
```

Особенности:
- контейнер выделяет отдельный узел под каждый элемент
- контейнер владеет временем жизни объекта
- дополнительные аллокации на каждый элемент
- ограниченный контроль над размещением памяти

---

### Intrusive контейнер (Boost.Intrusive / Linux-style)

struct Node {
K key;
V value;

list_hook lru_hook;
hash_hook set_hook;

};


Особенности:
- нет дополнительной обёртки-узла
- нет скрытых аллокаций со стороны контейнера
- объект может находиться одновременно в нескольких контейнерах
- полное управление временем жизни и размещением памяти остаётся у пользователя

---

## Архитектура LRU на intrusive

LRU требует:

1. O(1) поиск по ключу  
2. O(1) перемещение в начало (recently used)  
3. O(1) удаление самого старого элемента  

Классическая реализация на STL:

unordered_map<K, list::iterator>
list<pair<K,V>>


Недостатки:
- дублирование ключа
- двойные узлы (map + list)
- больше аллокаций
- хуже locality

В intrusive-версии используется один объект:

Node {
key
value
lru_hook
set_hook
}


Один и тот же Node одновременно участвует:
- в intrusive list (порядок LRU)
- в intrusive unordered_set (поиск)

Нет промежуточных узлов.
Нет дублирования ключа.
Меньше аллокаций.

---

## Контроль памяти

В данной реализации:

- контейнер не делает `new/delete`
- память управляется вручную
- возможно использование object pool или arena allocator
- можно добиться высокой предсказуемости latency

Это особенно важно для:
- real-time систем
- high-frequency trading
- embedded
- игровых движков

---

## Производственные плюсы

- меньше heap-аллокаций
- более компактный layout
- лучшая cache locality (при использовании пулов)
- отсутствие скрытых издержек контейнера
- возможность включения одного объекта в несколько структур

---

## Производственные риски

- требуется явное unlink перед delete
- легко получить UB при ошибке управления временем жизни
- более сложная семантика copy/move
- код менее очевиден по сравнению со STL

---

## Когда использовать intrusive

✔ Когда важен контроль памяти  
✔ Когда важна предсказуемость производительности  
✔ Когда объект должен участвовать в нескольких структурах  
✔ Когда стандартные контейнеры дают слишком большие накладные расходы  

❌ Когда приоритет — простота и безопасность  

---

## Вывод

Интрузивные структуры — это не замена STL,
а инструмент для системного и высокопроизводительного кода.

В контексте LRU cache они позволяют:

- убрать дублирование ключа
- сократить количество аллокаций
- сделать архитектуру более прямой
- контролировать layout памяти
